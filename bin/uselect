#!/usr/bin/env perl

# PODNAME: uselect
# ABSTRACT: interactive selection filter

use Modern::Perl;
use App::USelect;
use App::USelect::Selector;
use App::USelect::UI::Curses;
use Getopt::Long;
use Pod::Usage;
use Try::Tiny;
use autodie;

# VERSION

# Some debugging aids when things go weird
#use Carp::Always;
#open(STDERR, '>', '/tmp/uselect.log');

my %opt = (
    include_blanks  => 1,
    select_code     => '1',
);

process_options();

if (defined $opt{select_code}) {
    # Try evaluating the user code on its own first - we can tailor a better
    # error message this way.

    local $_ = ''; # silence warnings about $_ being uninitialised
    my $usercode = eval($opt{select_code}); ## no critic ProhibitStringyEval
    if ($@) {
        # Attempt to replace the default error message with something more
        # contextual. Not sure how robust this is.
        my $msg = $@;
        $msg =~ s/at \(eval \d+\) line \d+/in '$opt{select_code}'/g;
        say STDERR $msg;
        exit 4;
    }
}

if (not $opt{include_blanks}) {
    $opt{select_code} = '/\S/ and (' . $opt{select_code} . ')';
}

my $select_func = eval('sub { $_ = shift; ' . $opt{select_code} . '}'); ## no critic ProhibitStringyEval
pod2usage($@) if $@;    # this may still occur even if the first parse succeeded

chomp(my @lines = @ARGV ? @ARGV : <STDIN>);

my $app = App::USelect->new(
        text          => \@lines,
        is_selectable => $select_func,
    );
if ($app->selectable_line_count == 0) {
    say STDERR 'No selectable lines.';
    exit 2;
}
$app->run();

if ($app->has_errors) {
    say STDERR 'ERROR:', $app->errors;
    exit 3;
}
say $_->text for $app->selected_lines;
exit ($app->selected_line_count == 0);

#-------------------------------------------------------------------------------

sub process_options {
    my @options_spec = (
        "blank_lines|b"     => \$opt{include_blanks},
        "help|h|?"          => sub { pod2usage(0) },
        "select|s=s"        => \$opt{select_code},
        "version|v"         => sub {
            say "uselect v$App::USelect::VERSION"; exit 0 },
    );

    if (not GetOptions(@options_spec)) {
        pod2usage(1);
    }
}

__END__

=pod

=head1 SYNOPSIS

uselect [options] [select text]

  options:
     --blank_lines, -b
        Force blank lines to be selectable.

    --help, -h, -?
        Show this help.

    --select <perl expression>, -s <perl expression>
        Select only those lines for which given perl expression evaluates to
        true. The input lines are passed as $_.

    --version, -v
        Print the version and exit.

  Input lines can be specified on the command line after the options, otherwise
  they will be read from stdin.

=head1 DESCRIPTION

uselect is a reimplementation of iselect by Ralf S. Engelschall

    http://www.ossp.org/pkg/tool/iselect/

uselect is intended to be used as an interactive unix filter. Input lines are
displayed to the user, and selected lines are written to stderr.

=head1 SERVING SUGGESTIONS

fv() { vim $( find . -type f | sort | fgrep "$@" | uselect ); }

gv() { vim $( ack --heading --break "$@" | uselect -s '!/^\d+:/ ); }

=cut
