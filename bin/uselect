#!/usr/bin/env perl

use version; our $VERSION = qv('2011.06.28');

use Modern::Perl;
use App::USelect::Selector;
use App::USelect::Display;
use Getopt::Long;
use Try::Tiny;
use autodie;

# Makes warnings a bit easier to track down
# use Carp qw/ confess /;
# $SIG{__WARN__} = sub { confess };

# options
my $include_blanks = 0;
my $select_code;

process_options();

if (defined $select_code) {
    # Try evaluating the user code on its own first - it'll give a better
    # error message that way, rather than with our extra code added.
    #local $_ = '';      # silence warnings about $_ being uninitialised
    my $usercode = eval($select_code);
    die $@ if ($@)
}
else {
    $select_code = '1';
}

if (not $include_blanks) {
    $select_code = '/./ and (' . $select_code . ')';
}

my $select_func = eval('sub { $_ = $_[0]; ' . $select_code . '}');
usage($@) if $@;    # this may still occur even if the first parse succeeded

chomp(my @lines = @ARGV ? @ARGV : <STDIN>);

my $selector = App::USelect::Selector->new(
        text          => \@lines,
        is_selectable => $select_func,
    );
if (not $selector->selectable_lines) {
    say STDERR 'No selectable lines.';
    exit 0;
}

my $stdout = attach_console();

my $errors;
try {
    my $display = App::USelect::Display->new(selector => $selector);
    $display->run;
}
catch {
    $errors = $_;
};

detach_console($stdout);

if ($errors) {
    say STDERR 'ERROR:', $errors;
    exit 1;
}

say $_->text for $selector->selected_lines;

#-------------------------------------------------------------------------------

sub usage {
    say STDERR for @_;
    say STDERR "usage: $0 [options] [items]";
    say STDERR <<'END_USAGE';
options:
    --blank-lines|-b            make blank lines selectable

    --select|-s <perlcode>      only lines matching perlcode are selectable
                                input line is in $_

    --version|-V

END_USAGE

    exit 1;
}

sub attach_console {
    open(STDIN, '<', '/dev/tty');

    open my $stdout, '>&STDOUT';
    open(STDOUT, '>', '/dev/tty');

    return $stdout;
}

sub detach_console {
    my ($stdout) = @_;
    open(STDOUT, '>&', $stdout);
}

sub process_options {
    my @options_spec = (
        "blank_lines|b"     => \$include_blanks,
        "select|s=s"        => \$select_code,
        "version|V"         => sub { say "uselect v$VERSION"; exit 0 },
    );

    if (not GetOptions(@options_spec)) {
        usage();
    }
}
