#!/usr/bin/env perl

# PODNAME: uselect
# ABSTRACT: interactive selection filter

use Modern::Perl;
use App::USelect;
use App::USelect::Selector;
use App::USelect::UI;
use Getopt::Long;
use Pod::Usage;
use Try::Tiny;
use autodie;

# VERSION

# Some debugging aids when things go weird
#use Carp::Always;
#open(STDERR, '>', '/tmp/uselect.log');

# options
my $include_blanks = 0;
my $select_code;

process_options();

if (defined $select_code) {
    # Try evaluating the user code on its own first - we can tailor a better
    # error message this way.

    local $_ = ''; # silence warnings about $_ being uninitialised
    my $usercode = eval($select_code); ## no critic ProhibitStringyEval
    if ($@) {
        # Attempt to replace the default error message with something more
        # contextual. Not sure how robust this is.
        my $msg = $@;
        $msg =~ s/at \(eval \d+\) line \d+/in '$select_code'/;
        say STDERR $msg;
        exit 4;
    }
}
else {
    $select_code = '1';
}

if (not $include_blanks) {
    $select_code = '/./ and (' . $select_code . ')';
}

my $select_func = eval('sub { $_ = $_[0]; ' . $select_code . '}'); ## no critic ProhibitStringyEval
pod2usage($@) if $@;    # this may still occur even if the first parse succeeded

chomp(my @lines = @ARGV ? @ARGV : <STDIN>);

my $selector = App::USelect::Selector->new(
        text          => \@lines,
        is_selectable => $select_func,
    );
if (not $selector->selectable_lines) {
    say STDERR 'No selectable lines.';
    exit 2;
}

my $stdout = attach_console();

my $errors;
my $display;
my $error_code = 1;
try {
    $display = App::USelect::UI->new(selector => $selector);
    my $uselect = App::USelect->new(selector => $selector, ui => $display);
    $error_code = $uselect->run;
}
catch {
    $errors = $_;
}
finally {
    $display->end;
    undef $display;
};

detach_console($stdout);

if ($errors) {
    say STDERR 'ERROR:', $errors;
    exit 3;
}

say $_->text for $selector->selected_lines;

exit ($selector->selected_lines == 0);

#-------------------------------------------------------------------------------

sub process_options {
    my @options_spec = (
        "blank_lines|b"     => \$include_blanks,
        "help|h|?"          => sub { pod2usage(0) },
        "select|s=s"        => \$select_code,
        "version|v"         => sub {
            say "uselect v$App::USelect::VERSION"; exit 0 },
    );

    if (not GetOptions(@options_spec)) {
        pod2usage(1);
    }
}

sub attach_console {
    open(STDIN, '<', '/dev/tty');

    open my $stdout, '>&STDOUT';
    open(STDOUT, '>', '/dev/tty');

    return $stdout;
}

sub detach_console {
    my ($stdout) = @_;
    open(STDOUT, '>&', $stdout);
}

__END__

=pod

=head1 SYNOPSIS

uselect [options] [select text]

  options:
     --blank_lines, -b
        Force blank lines to be selectable.

    --help, -h, -?
        Show this help.

    --select <perl expression>, -s <perl expression>
        Select only those lines for which given perl expression evaluates to
        true. The input lines are passed as $_.

    --version, -v
        Print the version and exit.

  Input lines can be specified on the command line after the options, otherwise
  they will be read from stdin.

=head1 DESCRIPTION

uselect is a reimplementation of iselect by Ralf S. Engelschall

    http://www.ossp.org/pkg/tool/iselect/

uselect is intended to be used as an interactive unix filter. Input lines are
displayed to the user, and selected lines are written to stderr.

=head1 SERVING SUGGESTIONS

fv() { vim $( find . type f | sort | fgrep "$@" | uselect ); }

gv() { vim $( ack --heading --break "$@" | uselect -s '!/^\d+:/ ); }

=cut
